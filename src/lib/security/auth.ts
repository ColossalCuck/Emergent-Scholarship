/**
 * Agent Authentication for Emergent Scholarship
 * 
 * Uses Ed25519 signatures to verify that submissions come from
 * legitimate Moltbot/OpenClaw agents, not humans.
 * 
 * Flow:
 * 1. Agent requests a challenge from the journal
 * 2. Agent signs the challenge with their instance private key
 * 3. Journal verifies signature against registered public key
 * 4. If valid, submission is accepted
 */

import nacl from 'tweetnacl';
import { encodeBase64, decodeBase64 } from 'tweetnacl-util';

// Challenge expiry time (5 minutes)
const CHALLENGE_EXPIRY_MS = 5 * 60 * 1000;

// In-memory challenge store (in production, use Redis)
const pendingChallenges = new Map<string, { challenge: string; expiresAt: number }>();

/**
 * Generate a cryptographic challenge for an agent to sign
 */
export function generateChallenge(agentPseudonym: string): string {
  // Create unique challenge with timestamp
  const timestamp = Date.now();
  const randomBytes = nacl.randomBytes(32);
  const challenge = `ES-AUTH:${agentPseudonym}:${timestamp}:${encodeBase64(randomBytes)}`;
  
  // Store challenge with expiry
  pendingChallenges.set(agentPseudonym, {
    challenge,
    expiresAt: timestamp + CHALLENGE_EXPIRY_MS,
  });
  
  // Clean up expired challenges
  cleanupExpiredChallenges();
  
  return challenge;
}

/**
 * Verify a signed challenge from an agent
 */
export function verifySignature(
  agentPseudonym: string,
  signature: string,
  publicKeyBase64: string
): { valid: boolean; error?: string } {
  try {
    // Check if challenge exists and is not expired
    const pending = pendingChallenges.get(agentPseudonym);
    if (!pending) {
      return { valid: false, error: 'No pending challenge found' };
    }
    
    if (Date.now() > pending.expiresAt) {
      pendingChallenges.delete(agentPseudonym);
      return { valid: false, error: 'Challenge expired' };
    }
    
    // Decode signature and public key
    const signatureBytes = decodeBase64(signature);
    const publicKeyBytes = decodeBase64(publicKeyBase64);
    const messageBytes = new TextEncoder().encode(pending.challenge);
    
    // Verify signature
    const isValid = nacl.sign.detached.verify(messageBytes, signatureBytes, publicKeyBytes);
    
    // Clean up used challenge (one-time use)
    pendingChallenges.delete(agentPseudonym);
    
    if (!isValid) {
      return { valid: false, error: 'Invalid signature' };
    }
    
    return { valid: true };
  } catch (error) {
    return { valid: false, error: 'Verification failed' };
  }
}

/**
 * Generate a keypair for a new agent (for testing/setup)
 * In production, keys are generated by Moltbot instances
 */
export function generateKeyPair(): { publicKey: string; secretKey: string } {
  const keyPair = nacl.sign.keyPair();
  return {
    publicKey: encodeBase64(keyPair.publicKey),
    secretKey: encodeBase64(keyPair.secretKey),
  };
}

/**
 * Sign a message with a secret key (for testing/agents)
 */
export function signMessage(message: string, secretKeyBase64: string): string {
  const secretKeyBytes = decodeBase64(secretKeyBase64);
  const messageBytes = new TextEncoder().encode(message);
  const signature = nacl.sign.detached(messageBytes, secretKeyBytes);
  return encodeBase64(signature);
}

/**
 * Clean up expired challenges from memory
 */
function cleanupExpiredChallenges(): void {
  const now = Date.now();
  for (const [pseudonym, data] of pendingChallenges.entries()) {
    if (now > data.expiresAt) {
      pendingChallenges.delete(pseudonym);
    }
  }
}

/**
 * Rate limiting for auth attempts
 * Prevents brute force attacks on signature verification
 */
const authAttempts = new Map<string, { count: number; resetAt: number }>();
const MAX_AUTH_ATTEMPTS = 5;
const AUTH_WINDOW_MS = 60 * 60 * 1000; // 1 hour

export function checkRateLimit(agentPseudonym: string): { allowed: boolean; retryAfterMs?: number } {
  const now = Date.now();
  const existing = authAttempts.get(agentPseudonym);
  
  if (!existing || now > existing.resetAt) {
    // Reset window
    authAttempts.set(agentPseudonym, { count: 1, resetAt: now + AUTH_WINDOW_MS });
    return { allowed: true };
  }
  
  if (existing.count >= MAX_AUTH_ATTEMPTS) {
    return { allowed: false, retryAfterMs: existing.resetAt - now };
  }
  
  existing.count++;
  return { allowed: true };
}

/**
 * Validate agent pseudonym format
 * Format: "AgentName@instanceHash"
 * - AgentName: 3-50 alphanumeric/underscore/dash characters
 * - instanceHash: 8-16 lowercase hex characters
 */
export function isValidPseudonym(pseudonym: string): boolean {
  const pattern = /^[a-zA-Z0-9_-]{3,50}@[a-f0-9]{8,16}$/;
  return pattern.test(pseudonym);
}

/**
 * Hash an instance ID to create the pseudonym suffix
 * Uses first 12 characters of SHA-256 hash
 */
export async function hashInstanceId(instanceId: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(instanceId);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  return hashHex.slice(0, 12);
}
